// 1) After reset release, ctrl enable bits should be cleared within 2 cycles
  assert property (@(posedge clk_i) disable iff (!rst_ni)
    $rose(rst_ni) |=> ##[0:2] (reg2hw.ctrl.enable_ch0.q == 1'b0 && reg2hw.ctrl.enable_ch1.q == 1'b0)
  ) else $error("SVA: pattgen_reg_top: reg ctrl enables not cleared after reset");

  // 2) TL handshake response: request should yield response d_valid within 2 cycles
  assert property (@(posedge clk_i) disable iff (!rst_ni)
  (tl_reg_h2d.a_valid && !tl_reg_h2d.a_is_write && tl_reg_d2h.a_ready)
    |-> ##[0:2] tl_reg_d2h.d_valid
) else $error("SVA: pattgen_reg_top: accepted TL READ did not produce d_valid");

  // 3) reg access must hit exactly one address
  assert property (@(posedge clk_i) disable iff (!rst_ni)
    (reg_we || reg_re) |-> $onehot0(addr_hit)
  ) else $error("SVA: pattgen_reg_top: reg access did not hit exactly one address");

  // 4) reg_we_check must be onehot when writing (error trigger check)
  assert property (@(posedge clk_i) disable iff (!rst_ni)
    (reg_we && !addrmiss) |-> $onehot0(reg_we_check)
  ) else $error("SVA: pattgen_reg_top: reg_we_check not one-hot on write");
  //5
  assert property (@(posedge clk_i) disable iff (!rst_ni)
  $rose(intr_done_ch0_o) |-> ( reg2hw.intr_enable.done_ch0.q || reg2hw.intr_test.done_ch0.q )
) else $error("SVA: pattgen_core: intr_done_ch0 fired without enable/test");

// 6) intr_done_ch1 must only be asserted when enabled or test is active
assert property (@(posedge clk_i) disable iff (!rst_ni)
  $rose(intr_done_ch1_o) |-> ( reg2hw.intr_enable.done_ch1.q || reg2hw.intr_test.done_ch1.q )
) else $error("SVA: pattgen_core: intr_done_ch1 fired without enable/test");

// 7) bit/rep counters bounds
  // inside pattgen_chan module
  assert property (@(posedge clk_i) disable iff (!rst_ni)
  (bit_cnt_q <= len_q)) else $error("SVA: pattgen_chan: bit_cnt_q exceeded len_q");


  assert property (@(posedge clk_i) disable iff (!rst_ni)
  (rep_cnt_q <= reps_q)) else $error("SVA: pattgen_chan: rep_cnt_q exceeded reps_q");

  // 8) event_done one-cycle pulse
  // ensure event_done_o is a one-cycle pulse
	assert property (@(posedge clk_i) disable iff (!rst_ni)
  ( event_done_o |-> ##1 (!event_done_o) )) else $error("SVA: pattgen_chan: event_done_o not single-cycle");

// 9
 assert property (@(posedge clk_i) disable iff (!rst_ni)
  (!active_q) |-> ( (pcl_o === inactive_level_pcl_q) &&
                    (pda_o === inactive_level_pda_q) )) else $error("SVA: pattgen_chan: outputs not inactive when idle");
